<!DOCTYPE html>
<html>
<head>
	<script src="functions.js"></script>
	<link rel="icon" 
	      type="image/jpg" 
	      href="kippp.jpg">
	<script src="https://www.w3schools.com/lib/w3.js"></script>
	<link rel="stylesheet" type="text/css" href="style.css">
	<title>Asymptotic Analysis</title>
	<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML">
	</script>
</head>

<body>
	<script src="navbar.js"></script>

	<div id="container" style="">
		<img src="kippp.jpg" style="padding-top: 50px;" id="animate">	
	</div>

	<script src="mudkip.js"></script>

	<!-- TODO: use <span> for languages instead. -->

	<div style="margin-top:30px;padding:22px;padding-right: 240px;">
		<h1><span class="lang eng">Asymptotic Analysis</span><span class="lang tw">時間複雜度分析</span></h1>
		<h2 class="lang eng"><span class="lang eng">Introduction</span><span class="lang tw">簡介</span></h2>
		<p>
			<span class="lang eng">
				Whenever we write a program, it is useful to know how fast it will run. In most cases, the runtime will be mostly affected by the size of your input (amount of data you are dealing with). 
			</span>			
			<span class="lang tw">
				寫程式時, 知道程式執行的時間是個非常重要的事. 通常執行時間會與輸入資料的數量大有關西.			
			</span>
		</p>
		<p>
			<span class="lang eng">
				For example, bubblesort will run extremely quickly when there are 10 elements, but extremely slowly when there are 10000. 				
			</span>
			<span class="lang tw">
			 	譬如說, 泡沫排序若只要排10個元素, 就會及時完成, 而10000個元素會導致排序非常慢.
			</span>
		</p>
		<p>
			<span class="lang eng">
				The size of the input is usually denoted as a positive integer \(n\).
			</span>			
			<span class="lang tw">
				資料大小(數量)即以正整數 \(n\) 表示.
			</span>
		</p>
		<h2><span class="lang eng">Constants Don't Matter</span><span class="lang tw">常數直接作廢</span></h2>
		<p>
			<span class="lang eng">
				Let's look at this function as an example. <code>A.size</code> refers to the number of elements in <code>A</code>.
			</span>
			<span class="lang tw">
				未填
			</span>
		</p>
		<div class = "code" style="width: 300px; height: 110px;">
			<code><pre>
int isInArray(Array A, int k) {  
    for (int i = 0; i < A.size; i++) { 
        if (A[i] == k) return i; 
    } 
    return -1;
}
			</pre></code>
		</div>
		<div style="line-height: 1.3">
			<span class="lang eng">
				As you can see, the function loops through the array \(n\) times each time doing the following:
				<ol type="1">
					<li>checking a condition</li>
					<li>executing the interior of the code</li>
					<li>incrementing <code>i</code> as need be.</li>
				</ol>
			</span>			
			<span class="lang tw">
				可見, 以上程式會做3件事:
				<ol type="1">
					<li>檢查終端條件</li>
					<li>執行裡頭的code</li>
					<li>若未 return, 就會將 <code>i++</code></li>
				</ol>
			</span>

			<h3><span class="lang eng">"Constant time"</span><span class="lang tw">"常數時間"</span></h3>
			<p>
				<span class="lang eng">
					Now, basic things like accessing a member of an array, comparing two values, incrementing, all have something in common: they do <b>not</b> depend on the size of the input. <code>A</code> could have held \(1000000\) items and the operation <code>int i = 0;</code> or <code>A[i]</code> would have still taken the same amount of time. In fact, we'll give <code>int i = 0;</code> a runtime: a constant called \(c_0\) (in Whichh we don't particularly care what the value is). We call this runtime <b>constant</b> time. 
				</span>
				<span class="lang tw">
					喵
				</span>
			</p>
			<p>
				<span class="lang eng">
					For simplicity, the entire <code>if</code> statement will be represented just by one constant (even though there are several things going on inside), \(c_1\).
					Similarily, <code>i < A.size</code> and <code>i++</code> both take constant time. We give these two runtimes of \(c_2\) and \(c_3\). 
				</span>
				<span class="lang tw">
					米
				</span>
			</p>
			<p>
				<span class="lang eng">
					That being said, the entire loop is executed at most \(n\) times. This is important! This means that <b>the loop's runtime is related to the size of \(n\).</b> There will clearly be a difference if the array was \(10\) or \(1000000000\) items big!
				</span>
				<span class="lang tw">
					馬
				</span>				
			</p>
			<p>
				<span class="lang eng">
					Thus we can conclude that the function has a runtime of at most $$f(n) = c_0 + (c_1 + c_2)n.$$
					This is called the <b>worst-case</b> runtime because the function will, at worst, run that long. 
				</span>
				<span class="lang tw">
					馬
				</span>				
			</p>
			<p>
				<span class="lang eng">
					Being the nice people we are, however, we will pretend the constants do not exist and simplify to $$f(n) = n.$$
					The <b>best case</b> runtime would be \(c_0 + c_1 + c_2\), which of course is a constant time.
					<b>The takeaway: if the operation isn't related to the size of the input, it doesn't matter.</b>
				</span>
				<span class="lang tw">
					馬
				</span>				
			</p>
			<h3><span class="lang eng">Comparing functions</span><span class="lang tw">函數比較</span></h3>
			<p>
				<span class="lang eng">
					Now, let's have a look at this code:
				</span>
				<span class="lang tw">
					參考以下的 code:
				</span>				
			</p>
			<div class = "code" style="width: 350px; height: 140px;">
				<code><pre>
int hasDupli(Array A) {  
    for (int i = 0; i < A.size; i++) { 
        for (int j = i + 1; j < A.size; j++) {
        	if (A[i] == A[j]) return true;
    	}
    } 
    return false;
}
				</pre></code>
			</div>
			<p>
				<span class="lang eng">
					As you can see, the interior loop will first run 1 time, then 2 times, then up to \(n-1\) times, totaling up to \(1+2+3+...+n-1 = \frac{n(n-1)}{2}\) times. Ignoring constants, we can say that the runtime of this function is $$g(n) = n^2-n.$$
					You will see that, as \(n\) gets very large, \(g(n)\) will be larger than \(f(n)\), and the larger \(n\) gets, the larger the distance between the two become. Thus, \(g(n)\) acts somewhat like an asymptote to \(f(n)\), in that <b>at some point, \(f(n)\) is always guaranteed to never intersect with \(g(n)\).</b> Another way of saying this is that <b>\(g(n)\) grows much faster than \(f(n)\)</b>, a concept you may have learned in Calculus.
				</span>
				<span class="lang tw">
					馬米
				</span>				
			</p>
			<p>
				<span class="lang eng">
					Now, since we're talking about runtime, if your runtime grows very fast, your function will obviously take a lot more time. <b>This is called "inefficiency".</b> Since \(f(n)\) grows much slower than \(g(n)\), we often say that \(f(n)\) is more efficient than \(g(n)\), that is, an algorithm with runtime \(f(n)\) will be much, much faster than an algorithm with runtime \(g(n)\). 
				</span>
				<span class="lang tw">
					書齊
				</span>				
			</p>

			<!-- continue here -->
		<h2><span class="lang eng">Big O Notation</span><span class="lang tw">大 O 符號</span></h2>
			<p>
				<span class="lang eng">
					Of course, simplifying the function like that is not exactly accurate. There is a better way to show the worst-case runtime of an algorithm, and that is to use the Big O Notation.
				</span>
				<span class="lang tw">
					當然, 這樣簡化不是很精確的. 我們反而可以使用大 O 符號更準確地表達演算法的最慢執行時間.
				</span>
			</p>
			<h3><span class="lang eng">Definition</span><span class="lang tw">定義</span> </h3>
			<p>
				<span class="lang eng">
					Formally, given two functions \(f(n) > 0\) and \(g(n) > 0\),
				</span>
				<span class="lang tw">
					給定兩個函數 \(f(n) > 0\) 及 \(g(n) > 0\),
				</span>
			</p>
			<blockquote>
				<span class="lang eng">
					\(f(n) = O(g(n))\) iff there exists some constants \(c > 0\) and \(n_0 \ge 1\) that satisfies \(f(n) \le cg(n)\) for all \(n \ge n_0\).
				</span>
				<span class="lang tw">
					\(f(n) = O(g(n)) \leftarrow\rightarrow\) 存在常數 \(c > 0\) 與 \(n_0 \ge 1\) 使得 \(f(n) \le cg(n)\)  \(\forall n \ge n_0\).
				</span>
			</blockquote>
			<h3><span class="lang eng">Wait, what?</span><span class="lang tw">啥?</span> </h3>
			<span class="lang eng">
				An easier way of saying that is that at some point \(n_0\), the function \(g(n)\) will overtake (always be larger than) the function \(f(n)\). Since constants don't matter, however, we can multiply \(g(n)\) by any constant and the comparision will still be true. (It might just take longer for \(g(n)\) to overtake \(f(n)\), but it always will. Eventually.)
			</span>
			<span class="lang tw">
				意思就是, 從某個點 \(n_0\) 以後, \(g(n)\) 永遠會大於 \(f(n)\). 那麼, 因為我們沒有很在意常數, 我們就可以把 \(g(n)\) 乘上任何常數, 這樣不會影響函數比較結果. (不管你乘上什麼常數, 到某個點以後, \(g(n)\) 必定永遠超越 \(f(n)\)).
			</span>
		<div>
			<img src="./graph1.PNG" style="padding: 10px; float: left; width: 400px; height: 400px;">
			<p>
				<span class="lang eng">
					Let's look at this picture. The <span style="color: blue">blue</span> curve is \(f(n) = n\) and the <span style="color: red">red</span> curve is \(g(n) = \frac{1}{5}n^2\). We can see that at \(n = 5\), \(g(n)\) will overtake \(f(n)\). <b>Forever.</b> 
				</span>
				<span class="lang tw">
					如圖, 藍色的函數為 \(f(n) = n\), 並且紅色的為 \(g(n) = \frac{1}{5}n^2\). 可見, 從 \(n = 5\) 以後, \(g(n)\) 會<b>永遠</b>超過 \(f(n)\).
				</span>
			</p>
			<p>
				<span class="lang eng">
					This means that we can multiply \(g(n)\) by \(1\) and after any value after \(5\), \(f(n) \le 1g(n)\) will always be true. <b> Thus, our constants are \(c = 1\) and \(n_0 = 5\). </b> 
				</span>
				<span class="lang tw">
					因此, 我們可以把 \(g(n)\) 乘上 \(1\), 導致於任何 \(n \ge 5\), \(f(n) \le 1g(n)\) 都會是真的. 這兩個常數就是我們所謂的 \(c, n_0\), 在此 \(c = 1\) 以及 \(n_0 = 5\).
				</span>
			</p>
			<p>
				<span class="lang eng">
					We can then write $$f(n) = O(g(n))$$ or, equivalently: $$f(n) = O(\frac{1}{5}n^2)$$ 
					Which completes our proof. See? That was it!
				</span>
				<span class="lang tw">
					這樣就可以說 $$f(n) = O(g(n))$$ 或  $$f(n) = O(\frac{1}{5}n^2)$$ 證明就這麼簡單.
				</span>
			</p>
			<p>
				<span class="lang eng">
					On an unrelated note, we tend to not care about the constants, even in \(g(n)\), we can write the logically equivalent statement $$f(n) = O(n^2)$$
					Note that this is only <b>logically</b> equivalent. To prove \(f(n)=O(g(n))\), we will need to find the constants \(c, n_0\). However, we can obtain other useful information about \(f(n)\) by removing the constant.
				</span>
				<span class="lang tw">
					那麼, 因為我們常數不會很在意, \(\frac{1}{5}\) 拿掉之後可以得到邏輯等價的式子: $$f(n) = O(n^2)$$
					這邊要提醒一下, 剛剛的式子只是<b>邏輯等價</b>, 而且跟剛剛欲證明的 \(g(n)\) 完全無關. 但是當我們不管常數, 我們就可以得到一些有用的資料.
				</span>
			</p>
		</div>
		<h3><span class="lang eng">Really, the constant doesn't matter.</span><span class="lang tw">真的, 常數不重要.</span></h3>
		<p>
			<span class="lang eng">
				Going back to that example, we can try multiplying \(g(n)\) by \(c = 5\) instead to obtain \(5g(n) = n^2\). Why do that? 
			</span>
			<span class="lang tw">
				回頭去看以上的例子, 如果取 \(c = 5\), 我們可以得到 \(5g(n) = n^2\). 為何要這樣做呢?
			</span>
		</p>
		<p>
			<span class="lang eng">
				The answer is that it's much easier compare \(n\) and \(n^2\) now. Now we can see that the latter will overtake \(n\) at \(n_0 =1\). Of course, our conclusion of \(f(n) = O(g(n))\) will not change.
			</span>
			<span class="lang tw">
				答案就是, 比較\(n\)跟\(n^2\)就簡單很多了, 可馬上知道 \(n_0 = 1\), 而且\(f(n) = O(g(n))\)也不會變.
			</span>
		</p>

		<h3>
			<span class="lang eng">
				Okay, I sort of get it. But why do I care?
			</span>
			<span class="lang tw">
				喔, 好, 這樣懂了一些. 但是我幹嘛要學啊?			
			</span>
		</h3>
		<p>
			<span class="lang eng">
				You can think of big-O as a "big \(\le\)" for functions. <b>\(f(n) = O(g(n))\) means that \(f\) grows slower or at the same speed as \(g\).</b> <br> For example, in terms of speed,
			</span>
			<span class="lang tw">
				你可以把大O想成函數們的 "大\(\le\)". <b>\(f(n) = O(g(n))\) 的意思是 \(f\) 成長之速度比 \(g\) 慢或差不多.</b> 譬如說, 在速度方面,
			</span>
		</p>
		<ul>
			<li><span class="lang eng">A person = \(O(\)A horse\()\).</span><span class="lang tw">人=\(O(\)馬\()\)</span></li>
			<li><span class="lang eng">A horse = \(O(\)A car\()\).</span><span class="lang tw">馬=\(O(\)車\()\)</span></li>
			<li><span class="lang eng">Usain Bolt = \(O(\)A Honda\()\). (He is or slower than, or as fast as, a Honda.)</span><span class="lang tw">尤山·波特=\(O(\)本田\()\). (他比本田慢, 或者他跟本田的速度差不多.)</span></li>
		</ul>
		<p>
			<span class="lang eng">
				Now, it is important to remember that the function represents <b>runtime</b>. So if a function grows really fast, then an algorithm with that runtime is going to be very slow! 
			</span>
			<span class="lang tw">
				這邊也要說明一下, 這些函數們都是代表<b>執行時間</b>的, 所以如果某函數長得很快, 該演算法的執行時間就非常慢!
			</span>
		</p>
		<p>
			<span style="size: 110%; color: red; font-weight: bold; font-family: tahoma;"> 
				<span class="lang eng">
					Using the big-O notation, we can give an "upper bound" for a function; that is, the runtime \(f(n)\) is guaranteed to be <u>at worst</u> \(g(n)\).
				</span>
				<span class="lang tw">
					我們可以使用大O符號指定某個函數的上界; 也就是說, \(f(n)\) 這個執行時間最爛最爛只能是 \(g(n)\).
				</span>
			</span>
		</p>
		<h3>
			<span class="lang eng">
				Hmm, that makes sense. I am suddenly very interested now.
			</span>
			<span class="lang tw">
				喔, 原來是這樣. 我突然就對這個很有興趣.			
			</span>
		</h3>
		<p>
			<span class="lang eng">
				Let's try another example, this time comparing \(f(n)=10n^2\) and \(g(n)=4n^3+8n-2\). If you graph the two out, you can see that \(f(n) \le \frac{1}{4}g(n)\) after (roughly) \(n_0 = 10\). Thus we've found our constants, and can conclude \(10n^2 = O(4n^3+8n-2)\). 
			</span>
			<span class="lang tw">
				再看一個例子吧. 如果想要比較 \(f(n)=10n^2\) 與 \(g(n)=4n^3+8n-2\) 的話, 就畫一下圖, 然後就會發現大約\(n_0 = 10\), \(f(n) \le \frac{1}{4}g(n)\) 永遠是真. 找到了所需要的參數, 就可以直接說 \(10n^2 = O(4n^3+8n-2)\). 
			</span>
		</p>
		<p>
			<span class="lang eng">
				Of course, this looks really ugly. What can we do?
			</span>
			<span class="lang tw">
				當然, 看起來是滿醜的. 怎麼辦?			
			</span>
		</p>
		<p>
			<span class="lang eng">
				We can quickly prove that \(f(n)=O(4n^3)\), and thus also obtain \(f(n) = O(n^3)\). In general, we can discard terms that have lower <b>order of growth</b> to obtain a logically equivalent and simpler statement. For example, in \(O(7n^3 - 8n + 9)\) can be simplified to \(O(n^2)\). <b>If we just have a constant, like \(O(5)\) or \(O(\frac{3}{2}\)) or \(O(\sqrt{2})\), we call it \(O(1)\).</b>
			</span>
			<span class="lang tw">
				可以很快證出 \(f(n)=O(4n^3) \ \rightarrow \ f(n) = O(n^3)\). 通常我們可以 <b>把成長率比較慢的項子拿掉</b>, 而仍然得到邏輯等價以及較優雅的式子. 譬如說, \(O(7n^3 - 8n + 9)\) 可簡化成 \(O(n^2)\). <b>若函數最大項子為常數 (例: \(O(5)\), \(O(\frac{3}{2})\), \(O(\sqrt{2})\)), 可以直接寫 \(O(1)\).</b>
			</span>
		</p>
		<h3>
			<span class="lang eng">
				What do you mean, "quickly prove"? I hate drawing graphs.
			</span>
			<span class="lang tw">
				很快個頭啊, 畫圖本來就很慢.			
			</span>
		</h3>
		<p>
			<span class="lang eng">
				There is a "mathy" way to prove asymptoticity. (I made that word up.) There is also a cheaty way to do it, but forget that first.
			</span>
			<span class="lang tw">
				其實存在一個較數學的證法. (對不起.) 此外還存在個較作弊的方式, 但先裝不知道.			
			</span>
		</p>
		<p>
			<span class="lang eng">
				First, list out the inequality. For this example, we'll use \(3n+2\) and \(4n^2-10n\). We wish to prove that for all \(n \ge n_0\), the inequality $$3n+2 \le c(4n^2-10n)$$ is always true for some constants \(c\) and \(n_0\).
			</span>
			<span class="lang tw">
				首先, 把不等式列出來. 此例會用 \(3n+2\) 及 \(4n^2-10n\). 我們想要證對於任何 \(n \ge n_0\) 及某個 \(c > 0\), $$3n+2 \le c(4n^2-10n)$$ 都會是真. 
			</span>
		</p>
		<p>
			<span class="lang eng">
				Okay. Now, let's choose some \(c\). Let's try a simple \(c=1\). Now we need to find out if $$3n+2 \le 4n^2-10n$$
				Solving, we get $$n \ge \frac{13+\sqrt{201}}{8}$$
				Now, starting from what \(n_0\) would this statement be true? The answer is, of course, anything \(\ge \frac{13+\sqrt{201}}{8}\). So let's just take \(n_0 = 100\). Thus we have proven \(f(n)=O(g(n))\).
			</span>
			<span class="lang tw">
				好, 那現在要取 \(c, n_0\) 了. 如果隨便取 \(c = 1\) 會得到$$3n+2 \le 4n^2-10n$$然後$$n \ge \frac{13+\sqrt{201}}{8}$$從哪個\(n_0\)會永遠符合這個不等式呢? 答案的確是 \(\ge \frac{13+\sqrt{201}}{8}\) 的任何值都可以. 那就順便取 \(n_0 = 100\) 吧. 這樣就證完 \(f(n)=O(g(n))\).
			</span>
		</p>
		<p>
			<span class="lang eng">
				In fact, we can actually save choosing \(c\) for the very end.  $$3n+2 \le c(4n^2-10n)$$  $$ c \ge \frac{3n+2}{4n^2-10n}$$ We can see that the right side will approach a constant (i.e. zero), so we can choose some small \(c\) and large \(n_0\) to satisfy our inequality.
			</span>
			<span class="lang tw">
				事實上, 等最後取\(c\)也是可以.  $$3n+2 \le c(4n^2-10n)$$  $$ c \ge \frac{3n+2}{4n^2-10n}$$ 當 \(n\) 很大的時候, 右邊的值會趨近於一個常數, 所以一定存在比該常數大的 \(c\). 這樣可以取小的 \(c\) 且大的 \(n_0\) 好了.
			</span>
		</p>
		<p>
			<span class="lang eng">
				Here's another example: \(3n\) vs. \(2n\). We have $$3n \le 2cn$$ Since \(n \gt 0\) (how can an input size be negative?), we can divide to obtain $$3 \le 2c$$ In this case, any \(c \ge \frac{3}{2}\) and <b>any</b> \(n_0 \ge 1\) will work.
			</span>
			<span class="lang tw">
				再個例子: \(3n\) vs. \(2n\). $$3n \le 2cn$$ 因 \(n \gt 0\) (輸入數量怎麼可以是負的?), 可以把 \(n\) 除掉:$$3 \le 2c$$可知任何\(c \ge \frac{3}{2}\)而且任何\(n_0 \ge 1\)隨便取就行.
			</span>
		</p>
		<h3>
			<span class="lang eng">
				What about disprove? What if \(f(n) \ne O(g(n))\)?
			</span>
			<span class="lang tw">
				反證的話勒? \(f(n) \ne O(g(n))\)?
			</span>
		</h3>
		<p>
			<span class="lang eng">
				We must show that for <em>any</em> \(c\), it is impossible that \(f(n) \le cg(n)\). We do this by saving \(c\) to the very end and then showing that as \(n\) becomes very large, the inequality is unsatisfiable.
				A trivial case is \(n\) vs \(3\). We can quickly see that $$n \le 3c$$ is obviously not going to work, since \(c\) is a <b>constant</b> but \(n\) is a variable that can grow arbitrarily large, thus always surpassing any constant \(c\). 
			</span>
			<span class="lang tw">
				我們必須證明對於任何 \(c\), \(f(n) \le cg(n)\) 不可能永遠是真的. 證法是將\(c\)留到最後, 然後說明當 \(n\) 很大, 該不等式不會成立. 譬如說, \(n\) vs \(3\) 可以馬上看到 $$n \le 3c$$ 是錯的, 因為 \(c\) 是<b>常數</b>, 但是 \(n\) 可以隨意地長大, 且一定超過任何常數的值.
			</span>
		</p>
		<p>
			<span class="lang eng">
				Another example is $$2^n \le cn^{10}$$ $$\frac{2^n}{n^{10}} \le c$$ However, since the left side approaches \(\infty\) and \(c\) is a <b>constant</b>, the inequality can never be true.
			</span>
			<span class="lang tw">
				另外個例子: $$2^n \le cn^{10}$$ $$\frac{2^n}{n^{10}} \le c$$ 但因為當\(n\)很大,左邊的值會趨近於無限大, 並且超越任何常數, 所以不等式不可能成立.
			</span>
		</p>
		<h3><span class="lang eng">The cheaty way</span><span class="lang tw">作弊法</span></h3>
		<p>
			<span class="lang eng">
				Since we have already established that lower terms don't matter, in reality, <b>you can just prove big-O simply by comparing the largest terms of each function.</b> 
			</span>
			<span class="lang tw">
				從前就說明了成長率較低的項子不重要, 所以通常 <b>證明大O只要比兩函數的最大項子</b>.			
			</span>
		</p>
		<p>
			<span class="lang eng">
				For example, comparing $$f(n)=(\log_2{n})^2 + \sqrt{n} + 8n^3 - 2$$ and $$g(n) = \frac{n}{log_2{n}} + n^4 + 1 - 5n^2$$ would take an awful amount of take and work, but since we already know that \(f(n)=O(n^3)\) and \(g(n) = O(n^4)\) by looking at the largest terms, we can immediately see that \(g(n)\) grows faster than \(f(n)\).
			</span>
			<span class="lang tw">
				例如說, $$f(n)=(\log_2{n})^2 + \sqrt{n} + 8n^3 - 2$$ and $$g(n) = \frac{n}{log_2{n}} + n^4 + 1 - 5n^2$$ 正常比會累死, 所以先說明 \(f(n)=O(n^3)\) and \(g(n) = O(n^4)\) (看最大項子), 即可以馬上說 \(g(n)\) 長比 \(f(n)\) 快許多.
			</span>
		</p>
		<h3>
			<span class="lang eng">
				Examples and useful properties
			</span>
			<span class="lang tw">
				例子與性子
			</span>
		</h3>
			<ul>
				<li> \( n = O(n)\) </li>
				<li> \( 9n^3+7n^2-2n+3 = O(n^9)\) </li>
				<li> \( 2n^7-24n = O(n!)\)</li>
				<li> \( f(n) = O(f(n)) \) </li>
				<li> \( f(n) = O(g(n)) \land g(n) = O(h(n)) \rightarrow f(n) = O(h(n)) \)</li>
			</ul> 

		<h2><span class="lang eng">Other Notations</span><span class="lang tw">其他符號</span></h2>
		<h3><span class="lang eng">Big</span><span class="lang tw">大</span> Omega</h3>
		<p>
			<span class="lang eng">
				If Big-O is \(\le\), then Big Omega is \(\ge\). That is, 
			</span>
			<span class="lang tw">
				如果大O是 \(\le\), 那麼大 Omega 就是 \(\ge\).
			</span>
		</p>
		<blockquote>
			<span class="lang eng">
				\(f(n) = \Omega(g(n))\) iff there exists some constants \(c > 0\) and \(n_0 \ge 1\) that satisfies \(f(n) \ge cg(n)\) for all \(n \ge n_0\).
			</span>
			<span class="lang tw">
				\(f(n) = \Omega(g(n)) \leftarrow\rightarrow\) 存在常數 \(c > 0\) 及 \(n_0 \ge 1\) 使得 \(f(n) \ge cg(n) \forall n \ge n_0\).
			</span>
		</blockquote>
		<p>
			<span class="lang eng">
				That is, \(f(n)\) will grow <b>faster than or as fast as</b> \(g(n)\). 
			</span>
			<span class="lang tw">
				也就是說, \(f(n)\) 長比 \(g(n)\) <b>快或差不多速度</b>. 
			</span>
		</p>
		<p>
			<span class="lang eng">
				For example, the following statements are true:
			</span>
			<span class="lang tw">
				一些例子:			
			</span>
			<ul>
				<li> \( n^3 = \Omega(n^2)\) </li>
				<li> \( \frac{n}{4} = \Omega(n)\) </li>
				<li> \( n\log_2{n} = \Omega(n^2)\)</li>
				<li> \( n^{2} - 3n + 5 = \Omega(n^2)\)</li>
			</ul> 
		</p>
		<h3><span class="lang eng">Big</span><span class="lang tw">大</span> Theta</h3>
		<p>
			<span class="lang eng">
				If Big-O is \(\le\), then Big Theta is \(\approx\). That is, 
			</span>
			<span class="lang tw">
				如果大O是 \(\le\), 那麼大 Theta 就是 \(\approx\).
			</span>
		</p>
		<blockquote>
			<span class="lang eng">
				\(f(n) = \Theta(g(n))\) iff there exists some constants \(d > c > 0\) and \(n_0 \ge 1\) that satisfies \(cg(n) \le f(n) \le dg(n)\) for all \(n \ge n_0\).
			</span>
			<span class="lang tw">
				\(f(n) = \Theta(g(n)) \leftarrow\rightarrow \) 存在常數 \(d > c > 0\) 及 \(n_0 \ge 1\) 使得 \(cg(n) \le f(n) \le dg(n) \ \forall \ n \ge n_0\).
			</span>
		</blockquote>
		<p>
			<span class="lang eng">
				That is, \(f(n)\) will grow <b>as fast as</b> \(g(n)\). We can also see that $$ f(n) = \Theta(g(n)) \gets\to [f(n) = O(g(n)) \ and \ f(n) = \Omega(g(n))] $$ 
			</span>
			<span class="lang tw">
				也就是說, \(f(n)\) 跟 \(g(n)\) <b>成長速度差不多</b>. 那麼, $$ f(n) = \Theta(g(n)) \gets\to [f(n) = O(g(n)) \ 且 \ f(n) = \Omega(g(n))] $$ 
			</span>
		</p>
		<p>
			<span class="lang eng">
				For example, the following statements are true:
			</span>
			<span class="lang tw">
				一些例子:			
			</span>
			<ul >
				<li> \( 3(2^n)  = \Theta(2^n)\) </li>
				<li> \( \frac{9}{4} = \Theta(1)\) </li>
				<li> \( (n+1)^2 = \Theta(n^2)\)</li>
				<li> \( \log_2{n} = \Theta(\log_3{n})\)</li>
			</ul>
		</p>
		<p>
			<span class="lang eng">
				<b>Note: in computer science, we will always assume a log of base \(2\) if unspecified. However, since logarithms of all bases \(\gt 1\) are \(O(logn)\), whenever we see a log function, we can just express it as \(O(logn)\).</b>
			</span>
			<span class="lang tw">
				註: 資工的 log 的底如果沒有指定就假設為 \(2\). 不過, 底其實沒有很重要, 因為所以底 \(\gt 1\) 都是 \(O(logn)\), 所以看到 log 就直接寫 \(O(logn)\).
			</span>
		</p>
		<h3> <span class="lang eng">Little o</span> <span class="lang tw">小 o</span></h3>
			<p>
				<span class="lang eng">
					Little o can be thought of as a stricter version of Big O. It shows that \(f(n)\) can only grow slower than \(g(n)\), and <b>not at the same rate</b>. It is the \(\lt\) to Big O's \(\le\).
				</span>
				<span class="lang tw">
					小 o 可以想成比較嚴謹的大 O; \(f(n)\) 成長速度只能比 \(g(n)\) 慢, <b>不能差不多了</b>. 若大 O 是函數們的 \(\le\), 那麼小 o 為 \(\lt\).
				</span>
			</p>
			<blockquote>
				<span class="lang eng">
					\(f(n) = o(g(n))\) iff for <b>every</b> \(c > 0\), there is a constant \(n_0 \ge 1\) that satisfies \(f(n) \ge cg(n)\) for all \(n \ge n_0\).
				</span>
				<span class="lang tw">
					\(f(n) = \Omega(g(n)) \leftarrow\rightarrow\) 對於<b>每個</b> \(c > 0\) 會存在常數 \(n_0 \ge 1\) 使得 \(f(n) \ge cg(n) \forall n \ge n_0\).
				</span>
			</blockquote>
			<p>
				<span class="lang eng">
					That being said, it is impossible to manually prove <b>every</b> single \(c\), so instead we can use this definition: 
				</span>
				<span class="lang tw">
					當然, 證明每個 \(c\) 是不可能的事情, 所以我們通常會改用以下證小 o:
				</span>
				$$\displaystyle{\lim_{n\rightarrow \infty} \frac{f(n)}{g(n)} = 0}$$
			</p>
			<p>
				<span class="lang eng">
					For example, the following statements are true:
				</span>
				<span class="lang tw">
					一些例子:			
				</span>
				<ul>
					<li> \( \sqrt{n} = o(n^2)\) </li>
					<li> \( 2n^2 - 7 = o(n^3)\)</li>
					<li> \( \log_2{n} = o(n)\)</li>
					<li> \( 2^n  = o(3^{n})\) </li>
					<li> \( n  \ne o(n)\) </li>
				</ul>
			</p>
		<h3> <span class="lang eng">Little omega</span> <span class="lang tw">小 omega</span></h3>
			<p>
				<span class="lang eng">
					Similarly, little \(\omega\) can be thought of as a stricter version of Big \(\Omega\). It shows that \(f(n)\) can only grow faster than \(g(n)\), and <b>not at the same rate</b>. It is the \(\gt\) to Big \(\Omega\)'s \(\ge\).
				</span>
				<span class="lang tw">
					既然有了小 o, 那小 omega 就是理所當然的.
					小 \(\omega\) 可以想成比較嚴謹的大 \(\Omega\); \(f(n)\) 成長速度只能比 \(g(n)\) 快, <b>不能差不多了</b>. 也就是函數們的 \(\gt\).
				</span>
			</p>
			<p>
				<span class="lang eng">
					We omit the formal definition (which is just a reverse of little o's) and show the useful definition:
				</span>
				<span class="lang tw">
					省略正式定義, 直接看較有用的定義:
				</span>
				$$\displaystyle{\lim_{n\rightarrow \infty} \frac{f(n)}{g(n)} = \infty}$$
			</p>
			<p>
				<span class="lang eng">
					For example, the following statements are true:
				</span>
				<span class="lang tw">
					一些例子:			
				</span>
				<ul>
					<li> \( 4n = \omega(1)\) </li>
					<li> \( n! = \omega(3^n)\)</li>
					<li> \( 8n^3 = \omega(n)\)</li>
					<li> \( n^n  = \omega(n)\) </li>
					<li> \( n \ne \omega(n)\) </li>
				</ul>
			</p>

		<h2> <span class="lang eng">Exercises</span> <span class="lang tw">練習題目</span></h2>
		<p>
			<span class="lang eng">
				For the following functions \(f(n)\) and \(g(n)\), prove or disprove the following statements. If true, find suitable constants (You may also use any of <code>+ - * / ( )</code> for the \(c\) and any of <code>+ - * ( )</code> for \(n_0\). (As a result, you are not allowed to use functions like <code>sqrt</code> or <code>log</code>). Invalid expressions will not be checked.
			</span>
			<span class="lang tw">
				證或反證以下的式子. 成立的請輸入符合的常數. \(c\) 的也可輸入任何 <code>+ - * / ( )</code>, 則 \(n_0\) 也可輸入任何 <code>+ - * ( )</code>. 因此, 你不能輸入根號或log等函數. 若寫錯, 輸入的不會被檢查.
			</span>
		</p>
		<ol type="1" style="line-height: 2.5; ">
			<script src="q_file.js"></script>
		</ol>
	</div>
</body>

<script src="lang.js"></script>

<script src="q_ans.js"></script>

	
</html>